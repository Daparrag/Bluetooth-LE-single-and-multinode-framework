#ifndef FIRMWARE_BLE_H
#define FIRMWARE_BLE_H

#include "cube_hal.h"
#include "hal_types.h"
#include "bluenrg_gatt_server.h"
#include "bluenrg_gap.h"
#include "string.h"
#include "bluenrg_gap_aci.h"
#include "bluenrg_gatt_aci.h"
#include "hci_const.h"
#include "gp_timer.h"
#include "bluenrg_hal_aci.h"
#include "bluenrg_aci_const.h"
#include "hci.h"
#include "hci_le.h"
#include "hal.h"
#include "sm.h"
#include "debug.h"
#include "role_type.h"
#include "uart_support.h"
#include "stm32_bluenrg_ble.h"
#include <list.h>

/*copy macro*/


#ifndef COPY_VAR
#define COPY_VAR(dest,source) memcpy(dest,(void*)source,sizeof((source)))
#endif

/*multinode setup*/
#ifndef MULTINODE
#define MULTINODE 			0x0
#endif

#ifdef MULTINODE            				/*define MULTINODE for allows multinode network configuration */        
#define EXPECTED_NODES 7					
#else
#define EXPECTED_NODES 1
#endif
//#define MAX_SERVER_ATT_SIZE             0x03


/************************************************APP_BLE DEFINITIONS***************************************/
typedef enum /*used for return the result of and operation on the application*/
{
  APP_SUCCESS = 0x00,            /*!< command success applied */
  APP_ERROR = 0x01,              /*!< and error occour during the command execution*/
  APP_NOT_CONFIG= 0x02          /*!< not configuration is present before to applied a command*/
} APP_Status; 


typedef enum device_type{
  DEVICE_PHERISPHERAL,
  DEVICE_CENTRAL,
  DEVICE_BROADCASTER,
  DEVICE_OBSERVER
}dv_type_t;

/*device status*/
typedef enum device_state{
DEVICE_UNITIALIZED,				/*!< device_initialized >*/
DEVICE_DISCOVERY_MODE,			/*!< device set as discovery mode >*/
DEVICE_ADVERTISEMENT_MODE,		/*!< device set as adverticement mode >*/
DEVICE_SCAN_MODE,		        /*!< device set as scan mode >*/
DEVICE_READY_TO_INTERCHANGE,
DEVICE_READY,				/*!< device set as ready after connection stablishment >*/
DEVICE_NOT_CONNECTED			/*!< device set as not connected after many connetion set up tries>*/
}dv_state_t;

typedef struct{
  uint8_t services_to_find;
  uint8_t services_success_scanned;   /*!< flag fire to indicate that all of the services fot this profile had been scanned >*/  
}sv_ctrl_flags;

typedef struct{
uint8_t services_to_scan;						/*!<among of services to be scanned >*/
uint8_t services_scanned;						/*!<among of services scanned >*/
uint8_t char_to_scan;							/*!<among of characteristics to be scanned >*/
uint8_t char_scanned;							/*!<among of characteristics scanned >*/
uint8_t char_discovery_success;
}char_flags;

struct _app_attr_t{
  uint8_t CharUUID[16];            /*!< Control characteristic UUID.*/
  uint8_t charUuidType;            /*!< Control characteristic UUID_TYPE. 16 or 128 bits*/   
  uint8_t charValueLen;            /*!< Current length of the characteristic description*/
  uint8_t charProperties;          /*!< Characteristic properties.*/
  uint8_t secPermissions;         /*!< Permissions*/
  uint8_t gattEvtMask;            /*!< Type of event generated by GATT server*/
  uint8_t encryKeySize;           /*!< minimum encription key size requirement for this attr: 7 to 16*/
  uint8_t isVariable;             /*!< 0x00:fixed attr length 0x01:var attr length*/
  uint16_t CharHandle;             /*!< characteristic handle.*/
  uint8_t n_val;                  /*!< control counter of the number of values associate to this characteristic */
  struct _app_attr_t * next_attr;
};

typedef struct _app_attr_t app_attr_t;

struct _app_service_t{
  uint8_t ServiceUUID[16];              /*!<Control service UUID.*/
  uint16_t ServiceHandle;               /*!< Service handle.*/
  uint8_t service_uuid_type;            /*!<Control service UUID_TYPE. 16 or 128 bits*/
  uint8_t service_type;                 /*!<Type of service (primary or secondary) */
  uint8_t max_attr_records;             /*!< Maximum number of att-records that can be add to this service*/
  uint8_t n_attr;                       /*!< Control counter of the number of attributes add to this service*/
  struct _app_service_t * next_service;
  app_attr_t * attrs;
};


typedef struct _app_service_t app_service_t;


typedef struct{
  LIST_STRUCT(_service);
  uint8_t n_service;                  /*!< Control counter of the number of services associate to this application*/
  sv_ctrl_flags svflags;                  /*!< in the connection this indicates how many services had been discovered.*/  
  char_flags chrflags;
  app_service_t * services;
}app_profile_t;


typedef struct{/*structure for discovery configuration*/
  uint16_t sinterval;               /*!<  Time interval between two LE scans:0x0004-0x4000(period) >*/
  uint16_t swindows;                /*!<  Amoung of time for the duration of the LE scan:0x0004-0x4000(length) >*/
  uint8_t ownaddrtype;              /*!<  0x00:public address, 0x01: random device address >*/
  uint8_t fduplicates;              /*!<  0x00 do not  filter duplicates 0x01: filter duplicates >*/ 
}app_discovery_t;



typedef struct{/**structure for advertisement configuration*/
uint8_t adveventtype;           /*!<  0x00: connectable undirected adverticement 
                                      0x02: scanable undirect adverticement 
                                      0x03 non connectable undirect adverticement >*/
uint16_t advintervalmin;        /*!<  minimum advertisement interval for non direct advertisement: 0x0020-0x4000 
                                      default N=0x0800: Time=N*0.625ms>*/
uint16_t advintervalmax;        /*!<  minimum advertisement interval for non direct advertisement: 0x0020-0x4000 
                                      default N=0x0800: Time=N*0.625ms>*/
uint8_t advaddrstype;           /*!<  0x00:public address, 0x01: random device address >*/
uint8_t advfilterpoli;          /*!<  0x00:(default)allows scan request and connect request for any device,
                                      0x01:allows scan request for whitelist only but allows connect req for any device 
                                      0x02: scan request for any connect request for white list only 
                                      0x03: scan request and connect request for whitelist only >*/
//uint8_t localnamelength;/*firmware parameter*/
//uint8_t localname[];/*firmware parameter*/
//uint8_t serviceuuidlength;/*user parameter*/
//uint8_t serviceuuidlist[];/*user parameter*/
uint16_t slconnintervalmin;   /*!<  slave connection interval min value 
                                    connection interval min = slconnintervalmin * 1.25ms: 0x006-0x0C80; 
                                    0xFFFF:not specific min>*/
uint16_t slconnintervalmax;   /*!<  slave connection interval min value 
                                    connection interval max = slconnintervalmax * 1.25ms: 0x006-0x0C80;
                                    shall be slconnintervalmax >= slconnintervalmin 
                                    0xFFFF:not specific max >*/
}app_advertise_t;

/********************************************SERVICES HANDLER DEFINITIONS*****************************/

typedef enum{
	SERV_SUCCESS=0x00,
	SERV_ERROR=0x01
}SERV_Status;


typedef enum service_State{
  ST_SERVICE_DISCOVERY,							/*!< Service Handler in a service discovery mode >*/
  ST_CHAR_DISCOVERY						        /*!< Service Handler in a char discovery mode >*/
}sv_state_t;


typedef struct{
volatile uint8_t service_discovery;               /*!< this flag is fire when a new service has been discover >*/    
volatile uint8_t char_discovery;                  /*!< this flag is fire when a new char has been discover >*/
}sv_hdler_flags;

typedef struct{

  uint8_t serv_disc_mode;						/*!< this flag is setup for enable/disable the services scanning >*/    
  uint8_t char_disc_mode;						/*!< this flag is setup for enable/disable the characteristic discovery >*/
}servhandler_conf;


typedef struct{
sv_hdler_flags flags;							/*service handler event flags*/
servhandler_conf config;						/*service handler module configuration*/
}service_hdl_t;


/******************************************CONNECTION HANDLER DEFINITIONS**************************************/


typedef enum /*used for return the result of and operation on the application*/
{
  CHADLE_SUCCESS = 0x00,            /*!< command success applied >*/
  CHADLE_ERROR = 0x01,              /*!< and error occour during the command execution >*/
} CHADLE_Status; 

/*connection_status*/
typedef enum connection_State {
ST_UNESTABLISHED,					/*!< connection unestablished >*/
ST_STABLISHED,						/*!< connection stablished after discover services and characteristics >*/
ST_OBSERVER,						/*!< handler the communication as observer node >*/
ST_BROADCAST, 						/*!< handler the communication as broadcast node >*/
ST_CONNECTED_WAIT_CHAR_DISC,		/*!< ?Â¿ >*/
ST_CREATE_CONNECTION,  
ST_TIME_OUT  						/*!< the connection exceed the time for stablishement >*/	
}cn_state_t;

typedef struct{/*structure for connection configuration*/
uint16_t sinterval;               /*!<  Time interval between two LE scans:0x0004-0x4000(period)*/
uint16_t swindows;                /*!<  Amoung of time for the duration of the LE scan:0x0004-0x4000(length)*/
//uint8_t peer_addrtype; /*user parameter*/
//uint8_t peer_addrs [6];/*user parameter*/
uint8_t ownaddrtype;             /*!<  0x00:public address, 0x01: random device address >*/ 
uint16_t cintervalmin;           /*!<  minimum value for connection event interval shall be less or equal to  cintervalmax: 0x0006-0x0C80 >*/
uint16_t cintervalmax;           /*!<  maximum value for connection event interval shall be greater or equal to  cintervalmin: 0x0006-0x0C80>*/
uint16_t clatency;               /*!<  salve latency for connection in number of connection events:0x0000-0x01F4>*/
uint16_t stimeout;               /*!<  supervisor time out for LE link: 0x000A-0x0C80>*/
uint16_t clengthmin;             /*!<  minimum length of connection event needed for LE: 0x0000-0xFFFF time N*0.625ms>*/
uint16_t clengthmax;             /*!<  maximum length of connection event needed for LE: 0x0000-0xFFFF time N*0.625ms>*/
}config_connection_t;


/***************************************NETWORK MODULE DEFINITIONS******************************************/

typedef enum{
	NET_SUCCESS=0x00,			/*!< command success applied >*/
	NET_ERROR=0x01 				/*!< and error occour during the command execution >*/
}NET_Status;

typedef enum{
	NET_BROADCAST,				/*!< network module configured as a broadcast >*/
	NET_CONNECTED				/*!< network module configured as a master-slave >*/
}net_type_t;




typedef struct{ /*single connection structure*/
uint16_t Connection_Handle;           /*!< define one and only one connection handler x slave  */
/*NOTE: i guess that this can be part of service datastructure */app_profile_t * Node_profile;  /*!< could be one profile x slave (most convenient)*/
uint8_t device_type_addrs;            /*!< slave device addrs type*/
uint8_t device_address[6];            /*!< device address val*/
config_connection_t * cconfig;        /*!< device has a special connection configuration(optional) >*/
dv_state_t device_cstatus;            /*!< status of the device for this specific connection*/
servhandler_conf * sconfig;            /*!< device has a special services configuration(optional) >*/
cn_state_t connection_status;         /*!< this is the connection status.*/
sv_state_t service_status;

}connection_t;


/*network module control flags*/
typedef struct{
volatile uint8_t new_net_event;               /*!< this flag is fire when new event is setup for the event handler or by the application >*/
volatile uint8_t device_found;               /*!< this flag is fire when a new device has been found >*/
volatile uint8_t wait_end_procedure;         /*!< this flag is fire when a procedure is not ended >*/
volatile uint8_t service_discovery_evt;
volatile uint8_t attr_discovery_evt;
volatile uint8_t retry_conn;                 /*!< this flag is fire when a central node requere retry a connection with some pherispheral node>*/  
}net_flags;


/*network high module structure*/
typedef struct 
{
  net_flags flags;
  #ifdef MULTINODE
  uint8_t num_device_found;           /*<! this indicates the number of pherispheral success added to the network in a multinode mode>*/
  connection_t mMSConnection[EXPECTED_NODES]; /*<! here one connection per node mangement by the application >*/
  #else
  connection_t mMSConnection;         /*<! not multinode then a single connection is possible. >*/
  #endif
}network_t;


/*****************************EVENT HANDLER STRUCTURES**********************************************/
typedef struct {
  uint8_t event_type;
   hci_event_pckt event_data;
}event_t;


/***************************************************************************************************/



#endif /* NET_BLE_H*/